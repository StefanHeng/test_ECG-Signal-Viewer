import h5py
import json
import numpy as np
import pandas as pd

from bisect import bisect_left, bisect_right

from memory_profiler import profile

from dev_file import *


class EcgRecord:
    """Handles reading a .h5 file of ECG signal data, and sending datasets to graph plot.

    The .h5 file is created by `Ablation Database (ABLDB)`.
    Each .h5 file, contains a collection of .log files for a single surgery.
    Each .log file is a ECG signal dataset generated by sensor by Abbott,
    and it's one Segment of signal taken, artificially sliced.

    All .log files joined sequentially will form the entire sampling of all ECG data in the surgery.
    """

    EPOCH_START = pd.Timestamp('1970-01-01')
    UNIT_1US = pd.Timedelta('1us')

    # @profile
    def __init__(self, path):
        self.record = h5py.File(path, 'r')
        self.seg_keys = list(self.record.keys())  # keys to each segment compiled in the .h5 file
        self.annotations = list(self.record.attrs)
        self.sample_rate = self._get_sample_rate()

        self._sample_counts = self._get_sample_counts()
        self._sample_counts_acc = self._get_sample_counts_acc()  # Accumulated

    def _get_sample_rate(self):
        """Assumes that `sample_rate` is the same across all segments """
        seg = self.get_seg(self.seg_keys[0])
        return seg.get_metadata()['sample_rate']
        # return json.loads(self.record[self.seg_keys[0]].attrs['metadata'])['sample_rate']

    def _get_sample_counts(self):
        """ Helps to check which segment(s) is a time range located in """
        sample_counts = []
        for key in self.seg_keys:
            sample_counts.append(self.record[key].shape[1])
        return sample_counts

    def _get_sample_counts_acc(self):
        lst = [self._sample_counts[0]]
        for i, v in enumerate(self._sample_counts[1:]):
            val = v + lst[i]
            lst.append(val)
        return lst

    def get_seg(self, key):
        """
        :param key: A key to a segment in the internal dictionary
        :return: A single segment
        """
        return self.Segment(self.record[key])

    def get_seg_by_idx(self, idx_seg):
        return self.record[self.seg_keys[idx_seg]]

    def get_seg_data(self, idx_seg, idx_lead):
        """Syntactic sugar for getting data of a single lead of a segment """
        # return self.get_seg(self.seg_keys[idx_seg]).dataset[idx_lead]
        return self.record[self.seg_keys[idx_seg]][idx_lead]

    def get_annotation_header(self):
        return self.annotations[0]

    def get_annotations(self):
        """
        :return: All annotations across all segments
        """
        return self.annotations[2:]  # The first 2 elements are header and protocol respectively

    def get_lead_names(self):
        metadata = self.get_seg(self.seg_keys[0]).get_metadata()
        return [lead['name'] for lead in metadata['sigheader']]

    class Segment:
        """
        Each segment contains multiple `leads` taking in data concurrently
        """

        def __init__(self, dataset):
            """:param: dataset: A dataset in a .h5 file, 2 dimensional, #leads * #sample """
            self.dataset = dataset

        def get_metadata(self):
            return json.loads(self.dataset.attrs['metadata'])

    def locate_seg_idx(self, strt, end):
        """ Locates the segment(s) the sample_range spans, by index

        :param strt: integer start sample-count
        :param end: integer end sample-count
        :return: start, end segment-index tuple

        .. note:: In desencding frequency, sample_range should lie in 1 segment, or 2 segments if at edge, \\
        or multiple segments on sample global view
        """
        # Edge case when idx_end = edge of segment start, still need to include that 1 value hence `bisect_right`
        return bisect_left(self._sample_counts_acc, strt), bisect_right(self._sample_counts_acc, end)

    # @profile
    def get_samples(self, idx_lead, strt, end, step):
        """ Continuous samples of ecg magnitudes, specified by counted range

        :param idx_lead: index of the lead
        :param strt: start sample count
        :param end: end sample count
        :param step: every `step`-th value in the data sample is included
        :return: 1D array of ecg values

        .. note:: optimized for large sample_range
        .. seealso:: `EcgApp._Plot.get_fig()`
        """
        idx_strt, idx_end = self.locate_seg_idx(strt, end)
        strt = strt - self._sample_counts_acc[idx_strt]
        end = end - self._sample_counts_acc[idx_end] + 1  # for inclusive end
        if idx_strt == idx_end:
            return self.get_seg_by_idx(idx_strt)[idx_lead, strt:end:step]
        else:
            parts = [self.get_seg_by_idx(idx_strt)[idx_lead, strt::step]]
            for i in range(idx_strt+1, idx_end):
                parts.append(self.get_seg_by_idx(i)[idx_lead, ::step])
            parts.append(self.get_seg_by_idx(idx_end)[idx_lead, :end:step])
            return np.concatenate(parts)

    def time_str_to_sample_count(self, time):
        """
        Within range [0, maximum sample count)
        """
        timestamp = pd.Timestamp(time)
        delt_us = (timestamp - self.EPOCH_START) // self.UNIT_1US
        # Optimization: integer instead of float arithmetic while preserving accuracy
        count = delt_us * self.sample_rate // (10 ** 6)
        count = min(max(0, count), self._sample_counts_acc[-1] - 1)  # reduce to valid array index
        return count

    @staticmethod
    def example(path=DATA_PATH.joinpath(selected_record)):
        """Fast process a simple example for testing """
        return EcgRecord(path)


if __name__ == "__main__":
    help(EcgRecord)
