import h5py
import json
import numpy as np
import pandas as pd
import vaex as vx

from math import floor
from bisect import bisect_left, bisect_right

import pathlib
DATA_PATH = pathlib.Path("/Users/stefanh/Documents/UMich/Research/ECG-Signal-Viewer/data")
selected_record = "LOG_DHR50526570_09000e6f-001.h5"


class EcgRecord:
    """Handles reading a .h5 file of ECG signal data, and sending datasets to graph plot.

    The .h5 file is created by `Ablation Database (ABLDB)`.
    Each .h5 file, contains a collection of .log files for a single surgery.
    Each .log file is a ECG signal dataset generated by sensor by Abbott,
    and it's one Segment of signal taken, artificially sliced.

    All .log files joined sequentially will form the entire sampling of all ECG data in the surgery.
    """

    def __init__(self, path):
        self.record = h5py.File(path, 'r')
        self.seg_keys = list(self.record.keys())  # keys to each segment compiled in the .h5 file
        self.annotations = list(self.record.attrs)
        self._sample_counts = self._get_sample_counts()
        self._sample_counts_acc = self._get_sample_counts_acc()  # Accumulated

    def _get_sample_counts(self):
        """ Helps to check which segment(s) is a time range located in """
        sample_counts = []
        for key in self.seg_keys:
            sample_counts.append(self.get_seg(key).dataset.shape[1])
        return sample_counts

    def _get_sample_counts_acc(self):
        lst = [self._sample_counts[0]]
        for v in self._sample_counts[1:]:
            lst.append(v)
        return lst

    def get_seg(self, key):
        """
        :param key: A key to a segment in the internal dictionary
        :return: A single segment
        """
        return self.Segment(self.record[key])

    def get_seg_data(self, idx):
        """Syntactic sugar for getting all data of a segment """
        return self.get_seg(self.seg_keys[idx]).dataset

    def get_annotation_header(self):
        return self.annotations[0]

    def get_annotations(self):
        """
        :return: All annotations across all segments
        """
        return self.annotations[2:]  # The first 2 elements are header and protocol respectively

    class Segment:
        """
        Each segment contains multiple `leads` taking in data concurrently
        """

        def __init__(self, dataset):
            """:param: dataset: A dataset in a .h5 file, 2 dimensional, #leads * #sample """
            self.dataset = dataset
            self.sample_rate = self.get_sample_rate()

        def get_sample_rate(self):
            return self.get_metadata()['sample_rate']

        def get_metadata(self):
            return json.loads(self.dataset.attrs['metadata'])

        def get_lead_names(self):
            metadata = self.get_metadata()
            return [i['name'] for i in metadata['sigheader']]

        def get_lead(self, idx):
            """By index """
            return self.Lead(self, idx)

        class Lead:
            """Each lead contains the array of data taken """

            def __init__(self, seg, idx):
                self.seg = seg  # Link to outer class
                self.data = self.seg.dataset[idx]  # 1D array of sample
                self.metadata = self.seg.metadata_leads[idx]

            def get_ecg_values(self) -> np.ndarray:
                return self.data

    def locate_seg_idx(self, strt, end):
        """ Locates the segment(s) the sample_range spans, by index

        :param strt: integer start sample-count
        :param end: integer end sample-count
        :return: start, end segment-index tuple

        .. note:: In desencding frequency, sample_range should lie in 1 segment, or 2 segments if at edge, \\
        or multiple segments on sample global view
        """
        # Edge case when idx_end = edge of segment start, still need to include that 1 value hence `bisect_right`
        return bisect_left(self._sample_counts_acc, strt), bisect_right(self._sample_counts_acc, end)

    def get_samples(self, idx_lead, sample_range, step=1):
        """ Continuous samples of ecg magnitudes, specified by counted range

        :param idx_lead: index of the lead
        :param sample_range: integer start, end sample-count tuple
        :param step: every `step`-th value in the data sample is included
        :return: 1D array of ecg values

        .. note:: optimized for large sample_range
        .. seealso:: `ecg_plot.get_plot()`
        """
        strt, end = sample_range
        idx_strt, idx_end = self.locate_seg_idx(strt, end)
        strt = strt - self._sample_counts_acc[idx_strt]
        end = end - self._sample_counts_acc[idx_end] + 1  # for inclusive end
        if idx_strt == idx_end:
            return self.get_seg_data(idx_strt)[idx_lead][strt:end:step]
        else:
            parts = [self.get_seg_data(idx_strt)[idx_lead][strt::step]]
            for i in (idx_strt+1, idx_end):
                parts.append(self.get_seg_data(i)[idx_lead][idx_lead][:step])
            return np.concatenate(parts.append(self.get_seg_data(idx_strt)[idx_lead][:end:step]))

    # def join_lead(self, idx_lead=0):
    #     """ Joins values of a specific lead, across the entire record """
    #     ln = len(self.seg_keys)
    #     return np.concatenate([self.get_seg(i).get_lead(idx_lead).get_ecg_values() for i in range(ln)])

    @staticmethod
    def example(idx_segment=0, idx_lead=0, path=DATA_PATH.joinpath(selected_record)):
        """Fast process a simple example for testing """
        ecg_record = EcgRecord(path)
        key = list(ecg_record.seg_keys)[idx_segment]
        segment = ecg_record.get_seg(key)
        return ecg_record, segment, segment.get_lead(idx_lead)


if __name__ == "__main__":
    help(EcgRecord)
