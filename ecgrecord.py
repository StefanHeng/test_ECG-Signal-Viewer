import h5py
import json
import numpy as np
import pandas as pd

import pathlib
DATA_PATH = pathlib.Path("/Users/stefanh/Documents/UMich/Research/ECG-Signal-Viewer/data")
selected_record = "LOG_DHR50526570_09000e6f-001.h5"


class ECGRecord:
    """Handles reading a .h5 file of ECG signal data, and sending datasets to graph plot.

    The .h5 file is created by `Ablation Database (ABLDB)`.
    Each .h5 file, contains a collection of .log files for a single surgery.
    Each .log file is a ECG signal dataset generated by sensor by Abbott,
    and it's one Segment of signal taken, artificially sliced.

    All .log files joined sequentially will form the entire sampling of all ECG data in the surgery.
    """

    def __init__(self, path):
        self.record = h5py.File(path, 'r')
        self.annotations = list(self.record.attrs)

    def get_segment_keys(self):
        """:return: keys to each segment compiled in the .h5 file """
        return self.record.keys()

    def get_segment(self, key_idx):
        """
        :param key_idx: A key to a segment in the internal dictionary, or a index of the key
        :return: A single segment

        .. note:: This works because the internal record will not mutate
        """
        if isinstance(key_idx, int):
            lst = list(self.get_segment_keys())
            return self.Segment(self.record[lst[key_idx]])
        else:
            return self.Segment(self.record[key_idx])

    def get_annotation_header(self):
        return self.annotations[0]

    def get_annotations(self):
        """
        :return: All annotations across all segments
        """
        return self.annotations[2:]  # The first 2 elements are header and protocol respectively

    class Segment:
        """
        Each segment contains multiple `leads` taking in data concurrently
        """

        def __init__(self, dataset):
            """:param: dataset: A dataset in a .h5 file, 2 dimensional, #leads * #sample """
            self.dataset = dataset
            self.metadata = json.loads(self.dataset.attrs['metadata'])
            self.metadata_leads = self.metadata['sigheader']
            self.sample_rate = self.metadata['sample_rate']

        def get_metadata(self):
            """:return: Global metadata across all leads """
            metadata_global = self.metadata.copy()
            metadata_global.pop('sigheader')
            return metadata_global

        def get_lead_names(self):
            return [i['name'] for i in self.metadata_leads]

        def get_lead(self, idx):
            """By index """
            return self.Lead(self, idx)

        class Lead:
            """Each lead contains the array of data taken """

            def __init__(self, seg, idx):
                self.seg = seg  # Link to outer class
                self.arr_data = self.seg.dataset[idx]
                self.metadata = self.seg.metadata_leads[idx]

            def get_ecg_values(self) -> np.ndarray:
                return self.arr_data

        def get_time_axis(self):
            """
            :return: Incremental linspace of time in seconds starting from 0
            Local offset instead of across all segments, for now
            """
            num_sample = self.dataset.shape[1]
            sample_lin = np.linspace(0, num_sample - 1, num=num_sample)
            sample_lin = pd.to_datetime(sample_lin / (self.sample_rate / 1000), unit='ms')
            # sample_lin = sample_lin.map(lambda t: t.strftime('%H:%M:%S:%f'))
            return sample_lin

    def join_lead(self, idx_lead=0):
        """ Joins values of a specific lead, across the entire record """
        ln = len(self.get_segment_keys())
        return np.concatenate([self.get_segment(i).get_lead(idx_lead).get_ecg_values() for i in range(ln)])

    @staticmethod
    def example(idx_segment=0, idx_lead=0, path=DATA_PATH.joinpath(selected_record)):
        """Fast process a simple example for testing """
        ecg_record = ECGRecord(path)
        key = list(ecg_record.get_segment_keys())[idx_segment]
        segment = ecg_record.get_segment(key)
        return ecg_record, segment, segment.get_lead(idx_lead)


if __name__ == "__main__":
    help(ECGRecord)
